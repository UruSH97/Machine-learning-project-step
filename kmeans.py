# -*- coding: utf-8 -*-
"""kmeans.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10ammbqXtIN2m7XEkFTJYG39FsBy5cipa
"""





import numpy as np

"""## np.random.choice(a, size=None)

**a:** 1-D array-like or int
If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated as if it were np.arange(a).

**size:** Default is None, in which case a single value is returned.


"""

np.random.choice(10)

np.random.choice(10, 5)

a1 = np.array([3, 6, 2, 4, 1, 9])
np.random.choice(a1, 3)

"""## np.random.seed()

Computers follow a set of instructions to do anything; to generate random numbers as well; they use some seed. Hence random numbers are not truly random, they are hence called pseudorandom numbers.

np.random.seed() makes the random number predictable.
"""

np.random.seed(1)
np.random.choice(10)

"""## np.random.randn()

random.randn(d0, d1, ..., dn)

Return a sample (or samples) from the “standard normal” distribution.


"""

np.random.randn(10, 2)

# ?np.random.normal

"""## np.random.randint(low, high, [size])

"""

np.random.randint(1, 10, 2)

"""## numpy.arange([start], stop, [step])

Goes from start to stop -1

default start = 0
default step = 1
"""

np.arange(2, 10, 2)

"""## np.concatenate()

np.concatenate((a1, a2, ...), axis=0)

Join a sequence of arrays along an existing axis.

a1, a2, …sequence of array_like

-  All the input arrays must have same number of dimensions

- The arrays must have the same shape, except in the dimension corresponding to axis.

axis = 0 means first axis
"""

a1 = np.array([1, 2, 3])
a2 = np.array([4, 5, 6])
np.concatenate((a1, a2))

b1 = np.array([[1, 2], [3, 4]])
b2 = np.array([[5, 6], [7, 8]])

res = np.concatenate([b1, b2], axis = 1)3 #column wise
res

"""## np.linalg.norm()
To get the vector norm.
"""

np.linalg.norm([0, 5]) #sqrt of a**2-b**2

"""## np.linalg.norm(a-b)

The distance between two vectors v and w is the length of the difference vector v - w.

So, np.linalg.norm(a-b) can be used to get the distance between a and b.
"""

a = np.array([1, 2])
b = np.array([3, 4])

np.linalg.norm(a-b)

"""## np.argmin()

Returns the indices of the minimum values along an axis.
Default axis is None.

If axis = None, the array is flattened first.
"""

np.argmin(a)

"""##np.append(array, values, axis = None)

Append values to the end of an array.

axis : The axis along which values are appended. If axis is not given, both arr and values are flattened before use.

all the input arrays must have same number of dimensions

Note: append only creates a view
"""

a

a = np.append(a, [101, 210])

a

"""## np.mean(array, axis = None)
Compute the arithmetic mean along the specified axis.

default Axis = None means flatten and then find mean

In case of 1-d array, flattening does not make a difference.
"""

b1 = np.array([[1, 2], [3, 4]])
# b2 = np.array([[5, 6], [7, 8]])


np.mean(b1, axis = 1)

"""## Broadcast"""

b1

a = np.array([1,1])
b1+a

a+4

"""## Accessing array elements"""

a = np.array([4, 6, 8, 2, 3, 8, 10])
a[[1, 3, 6]]

a[[True, True, False, True, True, False, True]]

"""---

## Data generation for K-means
"""

np.random.randn(10, 2) + np.array([10, 20])

np.random.seed(0)
N = 2000
data1 = np.random.randn(N//3, 2) + np.array([2, 2])
data2 = np.random.randn(N//3, 2) + np.array([-3, -3])
data3 = np.random.randn(N//3, 2) + np.array([-5, 3])

X = np.concatenate((data1, data2, data3))

"""## Visualize data"""

import matplotlib.pyplot as plt

plt.scatter(X[:, 0], X[:, 1])

"""## Initialize cluster centers"""

k = 3

random_indices = np.random.randint(0, X.shape[0], k)
# random_indices
cluster_centers = X[random_indices]
cluster_centers

"""## Visualize the cluster centers as well"""

plt.scatter(X[:, 0], X[:, 1])
plt.scatter(cluster_centers[:, 0], cluster_centers[:, 1], marker = '+', s = 200, color = 'k')

"""## Assign data points to these three clusters (store this information in the cluster indicator (z))

<!-- Compute cluster indicator (z) -->
"""

def identify_cluster_of_each_data_point(X, k, cluster_centers):
  z = np.array([])

  for each in X:
    dists_from_each_center = [np.linalg.norm(cluster_centers[i] - each) for i in range(k)]
    # print(dists_from_each_center)
    chosen_cluster = np.argmin(dists_from_each_center)
    # print(chosen_cluster)
    z = np.append(z, chosen_cluster)
  return z

z = identify_cluster_of_each_data_point(X, k, cluster_centers)
z

"""## Visualize the clusters formed as per this z."""

plt.scatter(X[:, 0], X[:, 1], c = z)
plt.scatter(cluster_centers[:, 0], cluster_centers[:, 1], marker = '+', s = 200, color = 'k')

"""## Compute updated cluster centers"""

z == 2

def compute_cluster_centers(X, z, k):

  cluster_centers = np.array([np.mean(X[z == i], axis = 0) for i in range(k)])
  return cluster_centers

cluster_centers = compute_cluster_centers(X, z, k)
cluster_centers



"""## Iterations involving

(a) re-assigning data points to new clusters as per the new cluster centers formed.

(b) Re-compute cluster centers
"""

for i in range(10):
  z = identify_cluster_of_each_data_point(X, k, cluster_centers)

  plt.scatter(X[:, 0], X[:, 1], c = z)
  plt.scatter(cluster_centers[:, 0], cluster_centers[:, 1], marker = '+', s = 200, color = 'k')
  plt.show()

  cluster_centers = compute_cluster_centers(X, z, k)
  print(cluster_centers)